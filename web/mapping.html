<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROS 2 Web Controller - Mapping</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü§ñ</text></svg>" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script>
        // Apply theme immediately to prevent flash
        (function () {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            if (savedTheme === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
            }
            document.documentElement.classList.add('theme-loaded');
        })();
    </script>
    <link rel="stylesheet" href="/style.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.10.1/nipplejs.min.js"></script>
</head>

<body>
    <div id="map-container">
        <!-- Header -->
        <div id="header">
            <div class="logo">
                <div class="logo-icon">
                    <svg fill="#ffffff" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                        <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z" />
                    </svg>
                </div>
                <span class="logo-text">ROS 2 Web Controller</span>
            </div>
            <div class="nav-tabs">
                <a href="/mapping.html" class="nav-tab active">Mapping</a>
                <a href="/nav" class="nav-tab">Navigation</a>
            </div>
            <div id="status-badge">
                <span class="status-dot disconnected" id="statusDot"></span>
                <span id="statusText">Connecting...</span>
            </div>
            <button id="emergencyStopBtn" onclick="emergencyStop()"
                style="background: #dc2626; color: white; font-weight: 700; padding: 10px 20px; margin-left: auto; margin-right: 15px; border: 2px solid #991b1b; box-shadow: 0 4px 6px rgba(220, 38, 38, 0.3); border-radius: 8px; cursor: pointer;"
                title="Emergency Stop (Spacebar)">‚ö†Ô∏è E-STOP</button>
            <div class="theme-toggle" onclick="toggleTheme()" title="Toggle Theme">
                <span class="theme-icon" id="themeIcon">‚òÄÔ∏è</span>
            </div>
        </div>

        <!-- Canvas -->
        <canvas id="mapCanvas" class="grab"></canvas>

        <!-- Controls -->
        <div id="controls">
            <div class="control-section">
                <div class="control-label">Mapping Controls</div>
                <button id="mappingControlBtn" onclick="toggleMapping()"
                    style="width: 100%; margin-bottom: 10px; background: var(--primary-color);">
                    Start Mapping
                </button>
                <div class="input-group" style="margin-bottom: 10px;">
                    <input type="text" id="mapNameInput" placeholder="Map Name" class="input-field"
                        style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary);">
                </div>
                <div class="button-group">
                    <button class="btn-primary" onclick="saveMap()" style="flex: 1; background-color: #10b981;">Save
                        Map</button>
                    <button class="btn-primary" onclick="resetMapping()"
                        style="flex: 1; background-color: #ef4444;">Reset</button>
                </div>
            </div>
            <div class="control-section">
                <div class="control-label">View Options</div>
                <label class="checkbox-label">
                    <input type="checkbox" id="showLidar" checked>
                    <span>Show LiDAR</span>
                </label>
            </div>
            <div class="control-section">
                <div class="control-label">Zoom</div>
                <div class="button-group">
                    <button class="btn-icon" onclick="zoomIn()" title="Zoom In">+</button>
                    <button class="btn-icon" onclick="zoomOut()" title="Zoom Out">‚àí</button>
                    <button class="btn-icon" onclick="resetView()" title="Reset View">‚ü≤</button>
                </div>
            </div>
        </div>

        <!-- Info Panel -->
        <div id="info-panel">
            <div class="control-label">Robot Info</div>
            <div class="info-item">
                <span class="info-label">X Position</span>
                <span class="info-value" id="posX">---</span>
            </div>
            <div class="info-item">
                <span class="info-label">Y Position</span>
                <span class="info-value" id="posY">---</span>
            </div>
            <div class="info-item">
                <span class="info-label">Rotation</span>
                <span class="info-value" id="posTheta">---</span>
            </div>
            <div class="info-item">
                <span class="info-label">Map Size</span>
                <span class="info-value" id="mapSize">---</span>
            </div>
            <div
                style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color); text-align: center;">
                <small style="color: var(--text-secondary); font-size: 11px;">v1.0.0</small>
            </div>
        </div>

        <!-- Toast Container -->
        <div id="toast-container" style="position: fixed; top: 20px; right: 20px; z-index: 10000;"></div>

        <!-- Loading Overlay -->
        <div id="loading-overlay"
            style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; align-items: center; justify-content: center;">
            <div style="background: var(--bg-secondary); padding: 30px; border-radius: 12px; text-align: center;">
                <div class="spinner"
                    style="width: 50px; height: 50px; border: 4px solid var(--border-color); border-top-color: var(--primary-color); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 15px;">
                </div>
                <p style="color: var(--text-primary); margin: 0;">Processing...</p>
            </div>
        </div>

        <!-- Joystick -->
        <div id="joystick-zone"></div>

        <!-- Bottom Status -->
        <div id="bottom-status">
            <div class="stat-item">Scale: <span id="scaleValue">1.0</span>x</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');

        // Resize canvas to full screen
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (typeof drawMap === 'function') {
                drawMap();
            }
        }

        // Initialize canvas size (don't call drawMap yet as mapData isn't initialized)
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        window.addEventListener('resize', resizeCanvas);

        let ws;
        let mapData = null;
        let robotPose = null;
        let scanPoints = [];
        let showLidar = true;
        let scale = 1.0;
        let offsetX = 0;
        let offsetY = 0;
        let isFirstLoad = true;

        // Constant robot size in pixels (not affected by zoom)
        const ROBOT_SIZE_PX = 30;

        // Theme toggle
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            html.setAttribute('data-theme', newTheme);
            document.getElementById('themeIcon').textContent = newTheme === 'light' ? 'üåô' : '‚òÄÔ∏è';
            localStorage.setItem('theme', newTheme);
            drawMap();
        }

        // Load saved theme
        const savedTheme = localStorage.getItem('theme') || 'dark';
        if (savedTheme === 'light') {
            document.documentElement.setAttribute('data-theme', 'light');
            document.getElementById('themeIcon').textContent = 'üåô';
        }

        // Toast notification system
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Loading overlay
        function showLoading() {
            document.getElementById('loading-overlay').style.display = 'flex';
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }

        // Emergency stop function
        function emergencyStop() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'cmd_vel', linear: 0, angular: 0 }));
                ws.send(JSON.stringify({ type: 'emergency_stop' }));
                showToast('Emergency stop activated!', 'error');
            } else {
                showToast('Not connected to robot', 'error');
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch (e.key.toLowerCase()) {
                case ' ':  // Spacebar - Emergency stop
                    e.preventDefault();
                    emergencyStop();
                    break;
                case '+':
                case '=':
                    e.preventDefault();
                    zoomIn();
                    break;
                case '-':
                case '_':
                    e.preventDefault();
                    zoomOut();
                    break;
                case 'r':
                    e.preventDefault();
                    resetView();
                    break;
            }
        });

        // LiDAR toggle
        document.getElementById('showLidar').onchange = (e) => {
            showLidar = e.target.checked;
            drawMap();
        };

        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
        }

        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const port = window.location.port ? window.location.port : (window.location.protocol === 'https:' ? 443 : 80);
            ws = new WebSocket(protocol + window.location.hostname + ':' + port + '/ws');

            ws.onopen = () => {
                statusDot.classList.remove('disconnected');
                statusText.textContent = 'Connected';

                // Authenticate
                const token = getCookie('session_token');
                if (token) {
                    ws.send(JSON.stringify({ type: 'auth', token: token }));
                }
            };

            ws.onclose = (event) => {
                statusDot.classList.add('disconnected');
                statusText.textContent = 'Disconnected: ' + (event.reason || 'Retrying...');
                if (event.reason !== "Connection replaced by new session" && event.reason !== "Invalid authentication") {
                    setTimeout(connect, 1000);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
            };

            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);

                    if (msg.type === 'error') {
                        showToast(msg.message, 'error');
                        ws.close();
                        return;
                    }

                    if (msg.type === 'map') {
                        // Check if this is a different map (different dimensions)
                        const isNewMap = !mapData ||
                            mapData.width !== msg.width ||
                            mapData.height !== msg.height;

                        mapData = msg;
                        mapData.image = null; // Clear cached image
                        mapData.needsRedraw = true;

                        // Reset view if it's the first load OR if it's a new map
                        if (isFirstLoad || isNewMap) {
                            fitToCanvas();
                            isFirstLoad = false;
                        }

                        updateMapInfo();
                        drawMap();
                    } else if (msg.type === 'pose') {
                        robotPose = msg;
                        updatePoseInfo();
                        drawMap();
                    } else if (msg.type === 'scan') {
                        scanPoints = msg.points;
                        drawMap();
                    }
                } catch (e) { /* Ignore non-JSON messages */ }
            };
        }

        function updateMapInfo() {
            if (mapData) {
                document.getElementById('mapSize').textContent = `${mapData.width}√ó${mapData.height}`;
            }
        }

        function updatePoseInfo() {
            if (robotPose) {
                document.getElementById('posX').textContent = robotPose.x.toFixed(2) + ' m';
                document.getElementById('posY').textContent = robotPose.y.toFixed(2) + ' m';
                document.getElementById('posTheta').textContent = (robotPose.theta * 180 / Math.PI).toFixed(1) + '¬∞';
            }
        }

        function fitToCanvas() {
            if (!mapData) return;

            const scaleX = canvas.width / mapData.width;
            const scaleY = canvas.height / mapData.height;
            scale = Math.min(scaleX, scaleY) * 0.8;

            offsetX = 0;
            offsetY = 0;

            document.getElementById('scaleValue').textContent = scale.toFixed(2);
            drawMap();
        }

        function drawMap() {
            // Get theme colors
            const styles = getComputedStyle(document.documentElement);
            const bgPrimary = styles.getPropertyValue('--bg-primary').trim();
            const bgSecondary = styles.getPropertyValue('--bg-secondary').trim();
            const bgTertiary = styles.getPropertyValue('--bg-tertiary').trim();

            // Clear with gradient background
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, bgTertiary);
            gradient.addColorStop(0.5, bgSecondary);
            gradient.addColorStop(1, bgPrimary);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!mapData) return;

            // Define resolution once for all calculations
            const res = mapData.resolution;

            ctx.save();

            // Shared Transform for Map, Robot, Lidar
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(offsetX, offsetY);
            ctx.scale(1, -1);

            // Draw Map
            if (!mapData.image || mapData.needsRedraw) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = mapData.width;
                tempCanvas.height = mapData.height;
                const tempCtx = tempCanvas.getContext('2d');
                const imgData = tempCtx.createImageData(mapData.width, mapData.height);

                // Get map colors from CSS
                const mapFree = styles.getPropertyValue('--map-free').trim();
                const mapOccupied = styles.getPropertyValue('--map-occupied').trim();
                const mapUnknown = styles.getPropertyValue('--map-unknown').trim();

                const freeRGB = mapFree.match(/\d+/g).map(Number);
                const occupiedRGB = mapOccupied.match(/\d+/g).map(Number);
                const unknownRGB = mapUnknown.match(/\d+/g).map(Number);

                for (let i = 0; i < mapData.data.length; i++) {
                    const val = mapData.data[i];
                    const idx = i * 4;
                    let rgb;

                    if (val === 0) rgb = freeRGB;
                    else if (val === 100) rgb = occupiedRGB;
                    else rgb = unknownRGB;

                    imgData.data[idx] = rgb[0];
                    imgData.data[idx + 1] = rgb[1];
                    imgData.data[idx + 2] = rgb[2];
                    imgData.data[idx + 3] = 255;
                }
                tempCtx.putImageData(imgData, 0, 0);
                mapData.image = tempCanvas;
                mapData.needsRedraw = false;
            }

            // Map origin is in meters
            const originX = mapData.origin.position.x / res;
            const originY = mapData.origin.position.y / res;

            ctx.drawImage(mapData.image, originX, originY, mapData.width, mapData.height);

            // Draw LiDAR points (already in map frame meters from server)
            if (showLidar && scanPoints.length > 0) {
                ctx.fillStyle = 'rgba(255, 150, 0, 0.6)';
                const ptSize = 3 / scale;
                for (const [x, y] of scanPoints) {
                    // Scan points are in meters, convert to pixels
                    ctx.fillRect(x / res - ptSize / 2, y / res - ptSize / 2, ptSize, ptSize);
                }
            }

            // Draw Robot
            if (robotPose && mapData) {
                // Robot pose is in meters, convert to pixels
                const rx = robotPose.x / res;
                const ry = robotPose.y / res;

                ctx.save();
                ctx.translate(rx, ry);
                ctx.rotate(robotPose.theta);

                // Robot size in pixels (constant on screen)
                const robotRadius = (ROBOT_SIZE_PX / 2) / scale;

                // Robot body (circle)
                ctx.beginPath();
                ctx.arc(0, 0, robotRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#667eea';
                ctx.fill();

                // Direction indicator (triangle)
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(robotRadius * 1.2, 0);
                ctx.lineTo(-robotRadius * 0.5, robotRadius * 0.5);
                ctx.lineTo(-robotRadius * 0.5, -robotRadius * 0.5);
                ctx.fill();

                // Glow effect
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#667eea';
                ctx.beginPath();
                ctx.arc(0, 0, robotRadius, 0, Math.PI * 2);
                ctx.strokeStyle = '#a78bfa';
                ctx.lineWidth = 2 / scale;
                ctx.stroke();

                ctx.restore();
            }

            ctx.restore();
        }

        function zoomIn() {
            scale *= 1.2;
            document.getElementById('scaleValue').textContent = scale.toFixed(2);
            drawMap();
        }

        function zoomOut() {
            scale /= 1.2;
            document.getElementById('scaleValue').textContent = scale.toFixed(2);
            drawMap();
        }

        function resetView() {
            fitToCanvas();
        }

        // Panning
        let isDragging = false;
        let lastX, lastY;

        canvas.onmousedown = (e) => {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        };

        canvas.onmouseup = () => {
            isDragging = false;
        };

        canvas.onmouseleave = () => {
            isDragging = false;
        };

        canvas.onmousemove = (e) => {
            if (isDragging) {
                const dx = e.clientX - lastX;
                const dy = e.clientY - lastY;

                offsetX += dx / scale;
                offsetY += dy / scale;

                lastX = e.clientX;
                lastY = e.clientY;
                drawMap();
            }
        };

        // Joystick
        const manager = nipplejs.create({
            zone: document.getElementById('joystick-zone'),
            mode: 'static',
            position: { left: '50%', top: '50%' },
            color: '#667eea',
            size: 140
        });

        manager.on('move', (evt, data) => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                const linear = data.vector.y * 0.5;
                const angular = -data.vector.x * 1.0;

                ws.send(JSON.stringify({
                    type: 'cmd_vel',
                    linear: linear,
                    angular: angular
                }));
            }
        });

        manager.on('end', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'cmd_vel', linear: 0, angular: 0 }));
            }
        });

        // Keyboard controls (WASD)
        let keyState = {};
        document.addEventListener('keydown', (e) => {
            keyState[e.key.toLowerCase()] = true;
            updateKeyboardControl();
        });

        document.addEventListener('keyup', (e) => {
            keyState[e.key.toLowerCase()] = false;
            updateKeyboardControl();
        });

        function updateKeyboardControl() {
            let linear = 0;
            let angular = 0;

            if (keyState['w']) linear += 0.5;
            if (keyState['s']) linear -= 0.5;
            if (keyState['a']) angular += 1.0;
            if (keyState['d']) angular -= 1.0;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'cmd_vel', linear, angular }));
            }
        }

        // Check mapping status on page load
        async function checkMappingStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();

                const btn = document.getElementById('mappingControlBtn');
                if (status.mapping) {
                    // Mapping is running
                    btn.textContent = 'Stop Mapping';
                    btn.style.background = '#ef4444'; // Red color for stop
                } else {
                    // Mapping is stopped
                    btn.textContent = 'Start Mapping';
                    btn.style.background = 'var(--primary-color)';
                }
            } catch (error) {
                console.error('Error checking mapping status:', error);
            }
        }

        // Toggle mapping on/off
        async function toggleMapping() {
            const btn = document.getElementById('mappingControlBtn');

            if (btn.textContent === 'Start Mapping') {
                // Start mapping
                try {
                    showLoading();
                    const response = await fetch('/api/start_mapping', { method: 'POST' });
                    const result = await response.text();
                    hideLoading();

                    if (result === 'started' || result === 'already_running') {
                        btn.textContent = 'Stop Mapping';
                        btn.style.background = '#ef4444';
                        showToast('Mapping started', 'success');
                    }
                } catch (error) {
                    hideLoading();
                    showToast('Failed to start mapping', 'error');
                }
            } else {
                // Stop mapping with confirmation
                if (!confirm('Stop mapping? Current map progress will be lost if not saved.')) {
                    return;
                }
                btn.textContent = 'Stopping...';
                btn.disabled = true;
                try {
                    const response = await fetch('/api/stop_mapping', { method: 'POST' });
                    const result = await response.text();

                    btn.textContent = 'Start Mapping';
                    btn.style.background = 'var(--primary-color)';
                    btn.disabled = false;
                    showToast('Mapping stopped', 'info');
                } catch (error) {
                    btn.textContent = 'Stop Mapping';
                    btn.disabled = false;
                    showToast('Failed to stop mapping', 'error');
                }
            }
        }

        function saveMap() {
            const mapName = document.getElementById('mapNameInput').value;
            if (!mapName) {
                showToast('Please enter a map name', 'error');
                return;
            }
            showLoading();
            fetch('/api/save_map', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ map_name: mapName })
            })
                .then(response => {
                    hideLoading();
                    if (response.ok) showToast('Map saved successfully!', 'success');
                    else showToast('Failed to save map', 'error');
                })
                .catch(error => {
                    hideLoading();
                    showToast('Error saving map', 'error');
                });
        }

        function resetMapping() {
            if (confirm('Are you sure you want to reset mapping? Current progress will be lost.')) {
                fetch('/api/reset_mapping', { method: 'POST' })
                    .then(response => response.text())
                    .then(data => {
                        // Clear local map data
                        mapData = null;
                        scanPoints = [];
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        showToast('Mapping reset successfully', 'success');
                    })
                    .catch(error => showToast('Error resetting mapping', 'error'));
            }
        }

        // Initial setup
        checkMappingStatus(); // Check if mapping is already running
        connect();
    </script>
</body>

</html>