<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ROS 2 Web Controller</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü§ñ</text></svg>" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script>
        // Apply theme immediately to prevent flash
        (function () {
            const savedTheme = localStorage.getItem('theme') || 'dark';
            if (savedTheme === 'light') {
                document.documentElement.setAttribute('data-theme', 'light');
            }
            document.documentElement.classList.add('theme-loaded');
        })();
    </script>
    <link rel="stylesheet" href="/style.css">

</head>

<body>
    <div id="header">
        <div class="logo">
            <span class="logo-text">ROS 2 Web Controller</span>
        </div>
        <div class="nav-tabs">
            <a href="/mapping.html" class="nav-tab">Mapping</a>
            <a href="/nav" class="nav-tab active">Navigation</a>
        </div>
        <div id="status-badge">
            <span class="status-dot disconnected" id="statusDot"></span>
            <span id="statusText">Connecting...</span>
        </div>
        <button id="emergencyStopBtn" onclick="emergencyStop()"
            style="background: #dc2626; color: white; font-weight: 700; padding: 10px 20px; margin-left: auto; margin-right: 15px; border: 2px solid #991b1b; box-shadow: 0 4px 6px rgba(220, 38, 38, 0.3); border-radius: 8px; cursor: pointer;"
            title="Emergency Stop (Spacebar)">‚ö†Ô∏è E-STOP</button>
        <div class="theme-toggle" onclick="toggleTheme()" title="Toggle Theme">
            <span class="theme-icon" id="themeIcon">‚òÄÔ∏è</span>
        </div>
    </div>

    <canvas id="mapCanvas" class="crosshair"></canvas>

    <div class="panel" id="controls">
        <div class="panel-label">Navigation Controls</div>
        <div class="control-section" style="margin-bottom: 15px;">
            <label class="control-label" style="display: block; margin-bottom: 5px;">Select Map</label>
            <select id="mapSelect" onchange="loadMap()"
                style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid var(--border-color); background: var(--bg-tertiary); color: var(--text-primary);">
                <option value="" disabled selected>Loading maps...</option>
            </select>
        </div>
        <button id="navControlBtn" onclick="toggleNavigation()"
            style="margin-bottom: 12px; width: 100%; background: var(--primary-color);">
            Start Navigation
        </button>
        <div class="control-group">
            <button id="setGoalBtn" onclick="toggleGoalMode()">Set Goal</button>
            <button id="setPoseBtn" onclick="togglePoseMode()"
                style="background: linear-gradient(135deg, #f6d365 0%, #fda085 100%); margin-top: 10px;">Set Initial
                Pose</button>
        </div>
        <p style="font-size: 13px; color: var(--text-secondary); margin-bottom: 12px;">Drag map to pan, click Set Goal
            to place navigation target</p>
        <label class="checkbox-label">
            <input type="checkbox" id="showPlan" checked>
            <span>Show Global Plan</span>
        </label>
        <label class="checkbox-label">
            <input type="checkbox" id="showLidar" checked>
            <span>Show LiDAR</span>
        </label>
        <button onclick="zoomIn()">Zoom In (+)</button>
        <button onclick="zoomOut()">Zoom Out (‚àí)</button>
        <button onclick="resetView()">Reset View</button>
    </div>

    <!-- Toast Container -->
    <div id="toast-container" style="position: fixed; top: 20px; right: 20px; z-index: 10000;"></div>

    <!-- Loading Overlay -->
    <div id="loading-overlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 9999; align-items: center; justify-content: center;">
        <div style="background: var(--bg-secondary); padding: 30px; border-radius: 12px; text-align: center;">
            <div class="spinner"
                style="width: 50px; height: 50px; border: 4px solid var(--border-color); border-top-color: var(--primary-color); border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 15px;">
            </div>
            <p style="color: var(--text-primary); margin: 0;">Loading map...</p>
        </div>
    </div>

    <div class="panel" id="nav-status">
        <div class="panel-label">Navigation Status</div>
        <div class="status-item">
            <span class="status-label">Goal X</span>
            <span class="status-value" id="goalX">---</span>
        </div>
        <div class="status-item">
            <span class="status-label">Goal Y</span>
            <span class="status-value" id="goalY">---</span>
        </div>
        <div class="status-item">
            <span class="status-label">Distance</span>
            <span class="status-value" id="distance">---</span>
        </div>
        <div class="status-item">
            <span class="status-label">Status</span>
            <span class="status-value" id="navState">Idle</span>
        </div>
        <div
            style="margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border-color); text-align: center;">
            <small style="color: var(--text-secondary); font-size: 11px;">v1.0.0</small>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mapCanvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            if (typeof drawMap === 'function') drawMap();
        });

        let ws, mapData = null, robotPose = null, scanPoints = [], planPath = [];
        let scale = 1.0, offsetX = 0, offsetY = 0, isFirstLoad = true;
        let showPlan = true, showLidar = true, currentGoal = null;
        const ROBOT_SIZE_PX = 30;

        // Theme toggle
        function toggleTheme() {
            const html = document.documentElement;
            const currentTheme = html.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            html.setAttribute('data-theme', newTheme);
            document.getElementById('themeIcon').textContent = newTheme === 'light' ? 'üåô' : '‚òÄÔ∏è';
            localStorage.setItem('theme', newTheme);
            if (mapData) mapData.needsRedraw = true;
            drawMap();
        }

        // Load saved theme
        const savedTheme = localStorage.getItem('theme') || 'dark';
        if (savedTheme === 'light') {
            document.documentElement.setAttribute('data-theme', 'light');
            document.getElementById('themeIcon').textContent = 'üåô';
        }

        // Toast notification system
        function showToast(message, type = 'info') {
            const container = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            setTimeout(() => toast.remove(), 3000);
        }

        // Loading overlay
        function showLoading() {
            document.getElementById('loading-overlay').style.display = 'flex';
        }
        function hideLoading() {
            document.getElementById('loading-overlay').style.display = 'none';
        }

        // Emergency stop function
        function emergencyStop() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'cmd_vel', linear: 0, angular: 0 }));
                ws.send(JSON.stringify({ type: 'emergency_stop' }));
                showToast('Emergency stop activated!', 'error');
            } else {
                showToast('Not connected to robot', 'error');
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger if typing in input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

            switch (e.key.toLowerCase()) {
                case 'g':
                    toggleGoalMode();
                    break;
                case 'p':
                    togglePoseMode();
                    break;
                case 'escape':
                    if (goalMode) toggleGoalMode();
                    if (poseMode) togglePoseMode();
                    break;
                case ' ':  // Spacebar
                    e.preventDefault();
                    emergencyStop();
                    break;
                case '+':
                case '=':
                    e.preventDefault();
                    zoomIn();
                    break;
                case '-':
                case '_':
                    e.preventDefault();
                    zoomOut();
                    break;
                case 'r':
                    e.preventDefault();
                    resetView();
                    break;
            }
        });

        let reconnectAttempts = 0;
        let reconnectTimeout = null;
        const MAX_RECONNECT_DELAY = 30000; // 30 seconds
        const INITIAL_RECONNECT_DELAY = 1000; // 1 second

        function getCookie(name) {
            const value = `; ${document.cookie}`;
            const parts = value.split(`; ${name}=`);
            if (parts.length === 2) return parts.pop().split(';').shift();
        }

        function connect() {
            const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
            const port = window.location.port ? window.location.port : (window.location.protocol === 'https:' ? 443 : 80);
            ws = new WebSocket(protocol + window.location.hostname + ':' + port + '/ws');
            ws.onopen = () => {
                // Reset reconnect attempts on successful connection
                reconnectAttempts = 0;
                if (reconnectTimeout) {
                    clearTimeout(reconnectTimeout);
                    reconnectTimeout = null;
                }

                document.getElementById('statusDot').classList.remove('disconnected');
                document.getElementById('statusText').textContent = 'Connected';

                const cookies = document.cookie.split('; ');
                const sessionCookie = cookies.find(row => row.startsWith('session_token='));
                const token = sessionCookie ? sessionCookie.split('=')[1] : null;

                if (token) {
                    const authMsg = { type: 'auth', token: token };
                    ws.send(JSON.stringify(authMsg));
                } else {
                    console.warn('No session token found! WebSocket will not be authenticated.');
                }
            };
            ws.onclose = (event) => {
                statusDot.classList.add('disconnected');

                // Don't auto-reconnect for these reasons
                if (event.reason === "Connection replaced by new session" ||
                    event.reason === "Invalid authentication") {
                    statusText.textContent = 'Disconnected: ' + event.reason;
                    return;
                }

                // Calculate exponential backoff delay
                const delay = Math.min(
                    INITIAL_RECONNECT_DELAY * Math.pow(2, reconnectAttempts),
                    MAX_RECONNECT_DELAY
                );
                reconnectAttempts++;

                const seconds = Math.ceil(delay / 1000);
                statusText.textContent = `Reconnecting in ${seconds}s... (attempt ${reconnectAttempts})`;

                // Clear any pending reconnect
                if (reconnectTimeout) clearTimeout(reconnectTimeout);

                reconnectTimeout = setTimeout(() => {
                    connect();
                }, delay);
            };
            ws.onmessage = (event) => {
                try {
                    const msg = JSON.parse(event.data);

                    if (msg.type === 'error') {
                        alert(msg.message);
                        ws.close();
                        return;
                    }

                    if (msg.type === 'map') {
                        // Check if this is a different map (different dimensions)
                        const isNewMap = !mapData ||
                            mapData.width !== msg.width ||
                            mapData.height !== msg.height;

                        mapData = msg;
                        mapData.image = null;
                        mapData.needsRedraw = true;

                        // Reset view if it's the first load OR if it's a new map
                        if (isFirstLoad || isNewMap) {
                            fitToCanvas();
                            isFirstLoad = false;
                        }

                        drawMap();
                    }
                    else if (msg.type === 'pose') { robotPose = msg; updateDistance(); drawMap(); }
                    else if (msg.type === 'scan') { scanPoints = msg.points; drawMap(); }
                    else if (msg.type === 'plan') {
                        planPath = msg.path;
                        updateDistance();
                        drawMap();
                    }
                    else if (msg.type === 'nav_status') {
                        const navStateElem = document.getElementById('navState');
                        navStateElem.textContent = msg.status;
                        // Update styling based on state
                        navStateElem.classList.remove('active', 'failed');
                        if (msg.state === 'active') navStateElem.classList.add('active');
                        else if (msg.state === 'failed') navStateElem.classList.add('failed');
                    }
                } catch (e) { /* Ignore non-JSON messages */ }
            };
        }

        function fitToCanvas() {
            if (!mapData) return;
            scale = Math.min(canvas.width / mapData.width, canvas.height / mapData.height) * 0.8;
            offsetX = offsetY = 0;
            drawMap();
        }

        function drawMap() {
            const styles = getComputedStyle(document.documentElement);
            const bgPrimary = styles.getPropertyValue('--bg-primary').trim();
            const bgSecondary = styles.getPropertyValue('--bg-secondary').trim();
            const bgTertiary = styles.getPropertyValue('--bg-tertiary').trim();

            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, bgTertiary);
            gradient.addColorStop(0.5, bgSecondary);
            gradient.addColorStop(1, bgPrimary);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            if (!mapData) return;

            // Define resolution once for all calculations
            const res = mapData.resolution;

            ctx.save();
            // Apply shared transform for Map, Plan, Lidar, Robot, Goal
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(scale, scale);
            ctx.translate(offsetX, offsetY);
            ctx.scale(1, -1);

            if (!mapData.image || mapData.needsRedraw) {
                const tc = document.createElement('canvas');
                tc.width = mapData.width; tc.height = mapData.height;
                const tctx = tc.getContext('2d');
                const imgData = tctx.createImageData(mapData.width, mapData.height);

                const mapFree = styles.getPropertyValue('--map-free').trim();
                const mapOccupied = styles.getPropertyValue('--map-occupied').trim();
                const mapUnknown = styles.getPropertyValue('--map-unknown').trim();

                const freeRGB = mapFree.match(/\d+/g).map(Number);
                const occupiedRGB = mapOccupied.match(/\d+/g).map(Number);
                const unknownRGB = mapUnknown.match(/\d+/g).map(Number);

                for (let i = 0; i < mapData.data.length; i++) {
                    const val = mapData.data[i], idx = i * 4;
                    let rgb;
                    if (val === 0) rgb = freeRGB;
                    else if (val === 100) rgb = occupiedRGB;
                    else rgb = unknownRGB;
                    imgData.data[idx] = rgb[0]; imgData.data[idx + 1] = rgb[1]; imgData.data[idx + 2] = rgb[2]; imgData.data[idx + 3] = 255;
                }
                tctx.putImageData(imgData, 0, 0);
                mapData.image = tc;
                mapData.needsRedraw = false;
            }

            ctx.drawImage(mapData.image, mapData.origin.position.x / res, mapData.origin.position.y / res, mapData.width, mapData.height);

            // Draw global plan (plan points are in meters)
            if (showPlan && planPath.length > 1) {
                const isDark = !document.documentElement.getAttribute('data-theme') || document.documentElement.getAttribute('data-theme') === 'dark';
                ctx.strokeStyle = isDark ? '#00d4ff' : '#0066ff';
                ctx.lineWidth = 3 / scale;
                ctx.beginPath();
                for (let i = 0; i < planPath.length; i++) {
                    const [x, y] = planPath[i];
                    if (i === 0) ctx.moveTo(x / res, y / res);
                    else ctx.lineTo(x / res, y / res);
                }
                ctx.stroke();
            }

            // Draw LiDAR (scan points are in meters from server)
            if (showLidar && scanPoints.length > 0) {
                ctx.fillStyle = 'rgba(255, 150, 0, 0.6)';
                const ptSize = 3 / scale;
                for (const [x, y] of scanPoints) {
                    ctx.fillRect(x / res - ptSize / 2, y / res - ptSize / 2, ptSize, ptSize);
                }
            }

            // Draw goal (goal is in meters)
            if (currentGoal) {
                const gx = currentGoal.x / res;
                const gy = currentGoal.y / res;

                ctx.save();
                ctx.translate(gx, gy);
                ctx.rotate(currentGoal.theta);

                // Draw circle
                ctx.fillStyle = '#ef4444';
                ctx.beginPath();
                ctx.arc(0, 0, 10 / scale, 0, Math.PI * 2);
                ctx.fill();
                const isDark = !document.documentElement.getAttribute('data-theme') || document.documentElement.getAttribute('data-theme') === 'dark';
                ctx.strokeStyle = isDark ? '#fff' : '#1a202c';
                ctx.lineWidth = 2 / scale;
                ctx.stroke();

                // Draw orientation arrow
                const arrowLen = 20 / scale;
                const arrowWidth = 5 / scale;
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(arrowLen, 0);
                ctx.lineTo(arrowLen - arrowWidth, -arrowWidth);
                ctx.moveTo(arrowLen, 0);
                ctx.lineTo(arrowLen - arrowWidth, arrowWidth);
                ctx.strokeStyle = isDark ? '#fff' : '#1a202c';
                ctx.lineWidth = 3 / scale;
                ctx.stroke();

                ctx.restore();
            }

            // Draw robot (robot pose is in meters)
            if (robotPose && mapData) {
                const rx = robotPose.x / res;
                const ry = robotPose.y / res;

                ctx.save();
                ctx.translate(rx, ry);
                ctx.rotate(robotPose.theta);

                const rad = (ROBOT_SIZE_PX / 2) / scale;
                ctx.fillStyle = '#667eea';
                ctx.beginPath();
                ctx.arc(0, 0, rad, 0, Math.PI * 2);
                ctx.fill();

                const isDark = !document.documentElement.getAttribute('data-theme') || document.documentElement.getAttribute('data-theme') === 'dark';
                ctx.fillStyle = isDark ? '#fff' : '#1a202c';
                ctx.beginPath();
                ctx.moveTo(rad * 1.2, 0);
                ctx.lineTo(-rad * 0.5, rad * 0.5);
                ctx.lineTo(-rad * 0.5, -rad * 0.5);
                ctx.fill();
                ctx.restore();
            }

            ctx.restore();
        }

        function zoomIn() { scale *= 1.2; drawMap(); }
        function zoomOut() { scale /= 1.2; drawMap(); }
        function resetView() { fitToCanvas(); }

        function updateDistance() {
            if (planPath && planPath.length > 1) {
                // Calculate total path distance
                let totalDist = 0;
                for (let i = 0; i < planPath.length - 1; i++) {
                    const dx = planPath[i + 1][0] - planPath[i][0];
                    const dy = planPath[i + 1][1] - planPath[i][1];
                    totalDist += Math.sqrt(dx * dx + dy * dy);
                }
                document.getElementById('distance').textContent = totalDist.toFixed(2) + ' m';
            } else if (currentGoal && robotPose) {
                // Fallback to Euclidean distance if no plan yet
                const dx = currentGoal.x - robotPose.x;
                const dy = currentGoal.y - robotPose.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                document.getElementById('distance').textContent = dist.toFixed(2) + ' m';
            }
        }

        // Mouse handling - pan map or set goal
        // Mouse handling - pan map or set goal
        let isDragging = false, lastX, lastY;
        let goalMode = false;
        let poseMode = false;
        let goalStartPos = null;

        // Register event handlers after defining helper functions

        canvas.onmousedown = (e) => {
            if (!mapData) return;
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;

            if (goalMode || poseMode) {
                // In goal mode - set start position
                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left - canvas.width / 2;
                const clickY = e.clientY - rect.top - canvas.height / 2;

                const mapPixelX = (clickX / scale) - offsetX;
                const mapPixelY = offsetY - (clickY / scale);

                // Check bounds
                const originX = mapData.origin.position.x / mapData.resolution;
                const originY = mapData.origin.position.y / mapData.resolution;

                if (mapPixelX >= originX && mapPixelX <= originX + mapData.width &&
                    mapPixelY >= originY && mapPixelY <= originY + mapData.height) {
                    goalStartPos = {
                        x: e.clientX,
                        y: e.clientY,
                        mapX: mapPixelX * mapData.resolution,
                        mapY: mapPixelY * mapData.resolution
                    };
                }
            }
        };

        canvas.onmousemove = (e) => {
            if (!isDragging) return;

            if ((goalMode || poseMode) && goalStartPos) {
                // Preview orientation
                const dx = e.clientX - goalStartPos.x;
                const dy = e.clientY - goalStartPos.y;
                const theta = Math.atan2(-dy, dx);

                // We reuse currentGoal for visualization of the arrow
                currentGoal = { x: goalStartPos.mapX, y: goalStartPos.mapY, theta: theta };
                drawMap();
            } else if (!goalMode && !poseMode) {
                // Pan map
                offsetX += (e.clientX - lastX) / scale;
                offsetY += (e.clientY - lastY) / scale;
                lastX = e.clientX;
                lastY = e.clientY;
                drawMap();
            }
        };

        canvas.onmouseup = (e) => {
            if ((goalMode || poseMode) && goalStartPos) {
                const dx = e.clientX - goalStartPos.x;
                const dy = e.clientY - goalStartPos.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                let theta = 0;
                if (distance > 10) {
                    theta = Math.atan2(-dy, dx);
                }

                const targetX = goalStartPos.mapX;
                const targetY = goalStartPos.mapY;

                if (ws && ws.readyState === WebSocket.OPEN) {
                    if (goalMode) {
                        const goalMsg = { type: 'set_goal', x: targetX, y: targetY, theta: theta };
                        ws.send(JSON.stringify(goalMsg));
                        document.getElementById('goalX').textContent = targetX.toFixed(2) + ' m';
                        document.getElementById('goalY').textContent = targetY.toFixed(2) + ' m';
                        document.getElementById('navState').textContent = 'Goal Set';
                    } else if (poseMode) {
                        const poseMsg = { type: 'set_initial_pose', x: targetX, y: targetY, theta: theta };
                        ws.send(JSON.stringify(poseMsg));
                        showToast('Initial pose set successfully', 'success');
                    }
                } else {
                    showToast('WebSocket not connected', 'error');
                }

                goalStartPos = null;
                if (goalMode) toggleGoalMode();
                if (poseMode) togglePoseMode();
                // currentGoal = null; // Keep the goal visible!

                // If we set initial pose, we might want to clear the goal visualization
                // or maybe just leave it as the "last set point"
                if (poseMode) {
                    // For initial pose, maybe we don't want to show a "goal" arrow permanently?
                    // But user asked for "dot and arrow", so let's keep it for now.
                }

                drawMap();
            }
            isDragging = false;
        };

        // Goal mode toggle
        function toggleGoalMode() {
            goalMode = !goalMode;
            if (goalMode) poseMode = false; // Exclusive modes
            updateButtonStates();
        }

        function togglePoseMode() {
            poseMode = !poseMode;
            if (poseMode) goalMode = false; // Exclusive modes
            updateButtonStates();
        }

        function updateButtonStates() {
            document.getElementById('setGoalBtn').textContent = goalMode ? 'Cancel Goal' : 'Set Goal';
            document.getElementById('setGoalBtn').classList.toggle('active', goalMode);

            const poseBtn = document.getElementById('setPoseBtn');
            if (poseBtn) {
                poseBtn.textContent = poseMode ? 'Cancel Pose' : 'Set Initial Pose';
                poseBtn.classList.toggle('active', poseMode);
            }

            canvas.style.cursor = (goalMode || poseMode) ? 'crosshair' : 'grab';
        }

        document.getElementById('showPlan').onchange = (e) => { showPlan = e.target.checked; drawMap(); };
        document.getElementById('showLidar').onchange = (e) => { showLidar = e.target.checked; drawMap(); };

        function fetchMaps() {
            showLoading();
            fetch('/api/list_maps')
                .then(response => response.json())
                .then(maps => {
                    hideLoading();
                    const select = document.getElementById('mapSelect');
                    select.innerHTML = '';
                    if (maps.length === 0) {
                        const option = document.createElement('option');
                        option.text = "No maps found";
                        select.add(option);
                        showToast('No maps available', 'error');
                        return;
                    }

                    maps.forEach(map => {
                        const option = document.createElement('option');
                        option.value = map;
                        option.text = map;
                        select.add(option);
                    });

                    // Load the first map by default or the last selected one
                    const lastMap = localStorage.getItem('lastMap');
                    if (lastMap && maps.includes(lastMap)) {
                        select.value = lastMap;
                    } else {
                        select.value = maps[0];
                    }
                    loadMap();
                })
                .catch(error => {
                    hideLoading();
                    showToast('Error fetching maps', 'error');
                });
        }

        // Check navigation status on page load
        async function checkNavigationStatus() {
            try {
                const response = await fetch('/api/status');
                const status = await response.json();

                const btn = document.getElementById('navControlBtn');
                if (status.navigation) {
                    // Navigation is running
                    btn.textContent = 'Stop Navigation';
                    btn.style.background = '#ef4444'; // Red color for stop
                } else {
                    // Navigation is stopped
                    btn.textContent = 'Start Navigation';
                    btn.style.background = 'var(--primary-color)';
                }
            } catch (error) {
                console.error('Error checking navigation status:', error);
            }
        }

        // Toggle navigation on/off
        async function toggleNavigation() {
            const btn = document.getElementById('navControlBtn');
            const mapName = document.getElementById('mapSelect').value;

            if (btn.textContent === 'Start Navigation') {
                // Start navigation
                if (!mapName) {
                    alert('Please select a map first');
                    return;
                }

                try {
                    showLoading();
                    const response = await fetch('/api/start_navigation', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ map_name: mapName })
                    });

                    const result = await response.text();
                    hideLoading();

                    if (result === 'started' || result === 'already_running') {
                        btn.textContent = 'Stop Navigation';
                        btn.style.background = '#ef4444';
                        showToast('Navigation started', 'success');
                    }
                } catch (error) {
                    hideLoading();
                    showToast('Failed to start navigation', 'error');
                }
            } else {
                // Stop navigation with confirmation
                if (!confirm('Stop navigation? The robot will halt.')) {
                    return;
                }
                btn.textContent = 'Stopping...';
                btn.disabled = true;
                try {
                    const response = await fetch('/api/stop_navigation', { method: 'POST' });
                    const result = await response.text();

                    btn.textContent = 'Start Navigation';
                    btn.style.background = 'var(--primary-color)';
                    btn.disabled = false;
                    showToast('Navigation stopped', 'info');
                } catch (error) {
                    btn.textContent = 'Stop Navigation';
                    btn.disabled = false;
                    showToast('Failed to stop navigation', 'error');
                }
            }
        }

        function loadMap() {
            const mapName = document.getElementById('mapSelect').value;
            if (!mapName) return;

            localStorage.setItem('lastMap', mapName);
        }

        // Initial setup
        fetchMaps();
        checkNavigationStatus(); // Check if navigation is already running
        connect();
    </script>
</body>

</html>